"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[1213],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),d=l(n),p=i,m=d["".concat(c,".").concat(p)]||d[p]||u[p]||o;return n?a.createElement(m,s(s({ref:t},h),{},{components:n})):a.createElement(m,s({ref:t},h))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=d;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5241:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return u}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),s=["components"],r={sidebar_position:2},c="Learn",l={unversionedId:"learn",id:"learn",title:"Learn",description:"Network Overview",source:"@site/docs/learn.md",sourceDirName:".",slug:"/learn",permalink:"/docs/learn",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"History",permalink:"/docs/about/history"},next:{title:"Minima Incentive Program",permalink:"/docs/minimaincentiveprogram"}},h={},u=[{value:"Network Overview",id:"network-overview",level:2},{value:"Minima - Layer 1",id:"minima---layer-1",level:3},{value:"Maxima",id:"maxima",level:3},{value:"Layer 2 Architecture",id:"layer-2-architecture",level:3},{value:"MiniDapps",id:"minidapps",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"UTxO Model",id:"utxo-model",level:3},{value:"MMR (Merkle Mountain Range) Database",id:"mmr-merkle-mountain-range-database",level:3},{value:"Transaction Proof-of-Work (TxPoW)",id:"transaction-proof-of-work-txpow",level:3},{value:"The Burn",id:"the-burn",level:3},{value:"Transactions",id:"transactions",level:2},{value:"Transaction Outputs",id:"transaction-outputs",level:3}],d={toc:u};function p(e){var t=e.components,n=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"learn"},"Learn"),(0,o.kt)("h2",{id:"network-overview"},"Network Overview"),(0,o.kt)("p",null,"The Minima network consists of four distinct layers. Each layer contributes to Minima being a truly decentralized, peer-to-peer network for value and information exchange."),(0,o.kt)("h3",{id:"minima---layer-1"},"Minima - Layer 1"),(0,o.kt)("p",null,"Value transfer\nOn-chain"),(0,o.kt)("p",null,"Minima is a censorship resistant value transfer layer. All transactions are processed by all nodes on the network. It is flood-fill. It uses a P2P system as its backbone for communication between nodes."),(0,o.kt)("p",null,"The Minima blockchain is where all on-chain transactions are processed. Every node in the network collectively comes to consensus on the state of the blockchain so all transactions are accounted for.\nUsers initiate their transacting relationships on Layer 1, prior to moving off-chain to use Layer 2 for faster and cheaper transactions. As the trust layer of the protocol, Layer 1 is also used for settling any disputes between users on Layer 2."),(0,o.kt)("h3",{id:"maxima"},"Maxima"),(0,o.kt)("p",null,"Information transfer\nOff-chain"),(0,o.kt)("p",null,"Maxima is the censorship resistant information transport layer running over the Minima network. Communication is point-to-point. Messages can be sent, off-chain, to chosen connected peers."),(0,o.kt)("p",null,"Maxima is an information transport layer, enabling encrypted, peer-to-peer exchange of information between 1st and 2nd degree connections on the Minima network.\nMaxima can be used to build censorship resistant messaging applications over the Minima network and will be used for sending messages for Layer 2 communication."),(0,o.kt)("h3",{id:"layer-2-architecture"},"Layer 2 Architecture"),(0,o.kt)("p",null,"Value transfer\nOff-chain"),(0,o.kt)("p",null,"Layer 2 is fast, cheap and scalable. It enables instant peer-to-peer payments by creating bi-directional payment channels between participants, using technology similar to Bitcoin\u2019s Lightning Network.\nMinima can also support alternative scaling solutions such as state channels and side chains with the potential for further solutions in the future. "),(0,o.kt)("p",null,"Once users have set up their transacting relationship on Minima, they can perform all transactions off-chain, on Layer 2. This is where the bulk of peer-to-peer exchange between users of the network takes place. It is faster, as each payment is not settled on the blockchain and transactions are only processed by the relevant users rather than the entire network, as occurs on Layer 1.\nUsing multi-signature smart contracts and payment channels, users can keep a \u2018tab\u2019 of their unsettled balances indefinitely, until they wish to settle on Layer 1.\nThis unlocks the possibility of essentially unlimited transactions per second (TPS)."),(0,o.kt)("h3",{id:"minidapps"},"MiniDapps"),(0,o.kt)("p",null,"Web3 Applications"),(0,o.kt)("p",null,"MiniDapps are truly decentralised applications built using the functionality enabled by all components of the Minima network:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Value transfer on Minima"),(0,o.kt)("li",{parentName:"ol"},"Information transfer on Maxima"),(0,o.kt)("li",{parentName:"ol"},"Unlimited transaction per seconds on Layer 2 solutions")),(0,o.kt)("p",null,"MiniDapps are decentralized applications combining the utility provided by Minima, Maxima and Layer 2 with Minima\u2019s scripting language. The front-end for MiniDapps can be written using the widely known JavaScript, HTML and CSS.\nMinima\u2019s KISS scripting language is Turing-Complete, allowing for powerful smart contract driven applications. Building a MiniDapp is accessible to any web developer."),(0,o.kt)("h2",{id:"core-concepts"},"Core Concepts"),(0,o.kt)("h3",{id:"utxo-model"},"UTxO Model"),(0,o.kt)("p",null,"Minima uses the UTxO (Unspent Transaction Output) Model, like Bitcoin. A Transaction Output is a specific amount of Minima, identifiable through a unique ID called a coin ID. Each Transaction Output can be considered analogous to a physical coin in that they can represent different amounts of currency and must be spent in whole. "),(0,o.kt)("p",null,"The Minima blockchain keeps track of the UTxO set on the network and who can spend them. The UTxO set circulating in the network fluctuates as users spend coins and create new ones as outputs from transactions. The sum of the value of all the UTxOs in the network will equal at most 1 billion Minima."),(0,o.kt)("p",null,"One or more UTxOs are used as inputs into transactions and one or more new UTxOs will be created as outputs."),(0,o.kt)("p",null,"The example below shows a transaction of 30 Minima from Bob to Alice. A UTxO worth 50 Minima is used as an input and two new UTxOs are created as outputs - one worth 30 Minima which is sent to the recipient and one of 20 Minima which is returned to the sender as change. Just like change is received when physical coins are spent."),(0,o.kt)("h3",{id:"mmr-merkle-mountain-range-database"},"MMR (Merkle Mountain Range) Database"),(0,o.kt)("p",null,"As the tree is constantly pruned, users must keep track of their spent and unspent TxOs (transaction outputs)independently of the chain. Each TxO has a proof that forms part of a hash sum tree and these are stored in the user\u2019s MMR database.\nWhen a user wishes to spend their coins, they must provide the up to date valid proofs that it is unspent."),(0,o.kt)("h3",{id:"transaction-proof-of-work-txpow"},"Transaction Proof-of-Work (TxPoW)"),(0,o.kt)("p",null,"Another core concept in Minima is ",(0,o.kt)("strong",{parentName:"p"},"TxPoW")," - Transaction Proof of Work. Minima requires users to provide work, in the form of computing power, to \u2018mine\u2019 their own transactions. Once a user has contributed a small amount of work (~10 seconds) their transaction will be propagated around the network. This is in contrast to Bitcoin where users rely on miners with specific hardware to provide PoW and propagate their transactions on their behalf."),(0,o.kt)("p",null,"Transactions are held in ",(0,o.kt)("strong",{parentName:"p"},"TxPoW")," units, which may or may not become blocks. TxPoW units contain a user\u2019s transaction and the hashes of other unconfirmed transactions known to the user\u2019s node. TxPoW units become blocks if they, by chance, meet the level of difficulty required to become a block. "),(0,o.kt)("h3",{id:"the-burn"},"The Burn"),(0,o.kt)("p",null,"The Burn is a small cost (fee) which is incurred when sending transactions on the Minima network during times of high demand. This cost, denominated in Minima, is \u2018burned\u2019 i.e. removed from Minima's hard-capped supply, making Minima a deflationary currency as the overall circulating supply slowly decreases over time. "),(0,o.kt)("p",null,"The burn serves multiple purposes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A strong incentive to propagate and process a transaction: All users in the network will benefit from the decrease in supply as coins that are left become  more scarce and therefore more valuable."),(0,o.kt)("li",{parentName:"ul"},"A method for ordering transactions and regulating on-chain traffic: Similar to the fee model on other blockchains, the burn serves as a selection method for deciding which unconfirmed transactions will be added to a block. The higher the burn amount in a transaction, the more likely it is that a transaction will be added to a block. "),(0,o.kt)("li",{parentName:"ul"},"A mechanism for spam prevention by making Denial-of-Service (DoS) attacks expensive: The burn may be high during periods of heavy traffic or spam and, as it rises, traffic will decrease, self-regulating the system. The burn can be nil or very low when traffic is at manageable levels as the total amount is not important, only the relative burn amount in comparison to other transactions.")),(0,o.kt)("h2",{id:"transactions"},"Transactions"),(0,o.kt)("p",null,"Transaction Outputs & Inputs"),(0,o.kt)("h3",{id:"transaction-outputs"},"Transaction Outputs"),(0,o.kt)("p",null,"All transactions create new UTxOs (coins) as outputs, each coin is identifiable with a unique CoinID and consists of "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a specific amount of Minima and "),(0,o.kt)("li",{parentName:"ul"},"a script that determines the conditions required to spend the coin. This script is executed when a user attempts to spend the coin in a transaction and must return a value of TRUE to be spendable. See scripting")),(0,o.kt)("p",null,"Each coin has the following attributes:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Header"),(0,o.kt)("td",{parentName:"tr",align:null},"Title")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Paragraph"),(0,o.kt)("td",{parentName:"tr",align:null},"Text")))),(0,o.kt)("p",null,"Coin Attribute\nDescription\nCoinID\nThe globally unique identifier for a coin.\nThe coin id of a new UTxO is\nhash(first input coin in txn |  output_num_in_txn)\nAmount\nThe amount of 'Minima'. Even custom token transactions are just amounts of coloured Minima (see coloured coins)\nAddress\nThe hash of a script.\nIf no custom script is provided,the script will simply be RETURN(SIGNEDBY(","[PublicKey of coin owner]",") i.e. the  transaction must be signed by the coin owner before it can be spent.\nAll addresses are P2SH (Pay to Script Hash).\nTokenID\nThe token id. Minima is 0x00. Everything else has a full 64 byte hash. Tokens are created by colouring Minima.\nToken\nToken Details (see coloured coins)\nFloating\nTrue or False. Set when you create a transaction. If True, the coinid is ignored so that any valid coin that has the same amount, address and TokenID can be used.\nStore State\nTrue or False, depending on whether the state is stored for this coin\nState\nThe state variables(0-255) of the transaction this coin was created in. You can access this data from scripts.\nMMR Entry\nThe MMR database entry number for this coin\nSpent\nTrue or False, depending on whether this coin has been spent or not.\nCreated\nThe block number this coin was created in."),(0,o.kt)("p",null,"Transaction Inputs\nTransaction inputs identify which coins will be spent in the transaction, by providing the coin ID. One or more coins may be required depending on the value of the coins owned by the user and the amount they wish to spend.\nFor example if a user wishes to spend 100 Minima but they only have two coins worth 40 and 90 Minima, they must use both coins as inputs to the transaction and receive change of 30 as a new coin.\nWhen using a wallet application, the wallet will automatically choose which coins to use as inputs, however when constructing transactions manually, relevant coins must be selected to ensure the sum of the inputs is greater than or equal to the sum of the outputs.\nTransaction Structure\nA transaction is the main building block of the TxPoW unit. Transactions can be constructed in isolation but must be added into a TxPoW unit before it can be mined and propagated across the network.\nhas a list of inputs, outputs, state variables, linkhash and a transaction ID."),(0,o.kt)("p",null,"To send a transaction, a node must construct the transaction using one or more of their unspent coins as inputs. The outputs must also be specified, with the amount and the public address to send to. If the value of the input coins is greater than the value of the output, the change output must be defined as the difference to be returned to the sender, this is done automatically if the user uses a wallet application.\nThe burn must also be considered when constructing transactions, as this will affect the priority that a transaction has over others in the mempool. Any difference between inputs and outputs (including change) will be burned, removing that amount from circulation."),(0,o.kt)("p",null,"State Variables\nTransactions also include State Variables for storing public data and previous transaction states to retrieve information for scripts. 0-255 variables are allowed.\nLinkhash\nUsed for a burn transaction. The linkhash of a burn transaction is the transaction ID of the main transaction it relates to. This means that the burn transaction can only be spent with the transaction it is linked to.  For normal transactions, it is set to 0x00.\nDiagram: Main transaction  structure\nTransaction ID: Hash(Transaction object)\nInputs\nOutputs\nState Variables (0-255)\nLinkhash (0x00)"),(0,o.kt)("p",null,"Diagram: Burn transaction structure\nTransaction ID: Hash(Transaction object)\nInputs (matching the main txn)\nOutput (amount to burn)\nState Variables (matching the main txn)\nLinkhash (main txn ID)"),(0,o.kt)("p",null,"Transaction Validity"),(0,o.kt)("p",null,"For a transaction to be valid, it must:\nIt must have at least one, and up to 256 coin inputs\nIt must have no more than 255 outputs\nAll inputs and outputs must be valid Minima amounts\nThe sum of inputs must be greater than or equal to the sum of the outputs for each Token ID.\nHave unique coin IDs for each input coin"),(0,o.kt)("p",null,"MMR Database\nAs the blockchain is heavily pruned, users must store proof that their coins (UTxOs) are unspent. This is the role of the MMR database. The MMR (Merkle Mountain Range) proof db is a hash sum tree containing the proofs for all coins, spent (STxOs) or unspent (UTxOs) in the system."),(0,o.kt)("p",null,"Users do not store the whole MMR for all the coins in the system, as this would be too burdensome, rather they only store the paths to their own coins which must be provided when a user wishes to spend their coins."),(0,o.kt)("p",null,"The tree is append-only and is updated with each new block as coins are spent and created. When a coin is spent, the Spent state of the coin changes from false to true and the MMR Proof for the coin is updated.\nWhen a new coin is created (as an output to a transaction), a new leaf node is added to the tree for the new, unspent coin, creating new peaks and a new root hash.\nTherefore, for a user to prove the validity of their coins (i.e. that they are unspent), a user must remain up to date with the chain to ensure they hold the most up to date coin proofs.\nWhen a user wishes to spend their coins, they must prove their coins are unspent by providing:\nThe MMR Root hash from the most recent block\nThe proof path to the entry of the coin\nA node receiving the proofs will check the coins are valid by summing the hashes provided and ensuring it matches the Merkle root they possess themselves.\nDiagram: A complete Merkle Mountain Range (MMR) with three peaks and root"),(0,o.kt)("p",null,"A brief overview: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.md"},"https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.md"),"\nDetailed overview: ",(0,o.kt)("a",{parentName:"p",href:"https://petertodd.org/2016/delayed-txo-commitments"},"https://petertodd.org/2016/delayed-txo-commitments")),(0,o.kt)("p",null,"TxPoW Units (Blocks)\nBefore a transaction can be posted to the network, it must be added to a TxPoW unit with other essential data and \u2018mined\u2019.\nDuring the TxPoW creation process, in addition to the main transaction, unconfirmed transactions in the mempool will also be added to the body of the TxPoW unit, serving to further propagate mempool transactions to known peers.\nAfter being mined, a TxPoW unit will be propagated to the network either as a block if it meets the network block difficulty level, or as a basic TxPoW unit which serves only to propagate known unconfirmed transactions. This ensures block creation is a \u2018chance\u2019 encounter.\nA node can carry out several activities with a TxPoW unit depending on the situation:\nGenerate: When a user wishes to send a transaction, or is required to send a Pulse to the network, their node will generate (construct) a TxPoW unit containing their transaction and the hashes of other unconfirmed transactions it knows about in the mempool. TxPoW units are analogous to compact blocks in Bitcoin. See TxPoW Generation\nMine: Before a node can propagate its TxPoW unit to the network, it must mine the TxPoW unit by cycling through different nonces (numbers), adding the nonce to the TxPoW header and hashing the result. Once the resulting hash meets the level of difficulty required by the network (~10 seconds work), they can propagate their TxPoW unit to other nodes in the network.\nNote: The transaction difficulty sets the minimum amount of work a node must provide before their TxPoW can be propagated across the network (~10 seconds work). This ensures the network has received the transactions in their TxPoW unit, however this does not automatically mean that their transactions are in a block.\nTxPoW units only become blocks if, by chance, the block difficulty is met in the process of meeting the transaction difficulty.\nCheck: When a node receives a TxPoW unit from another node on the network, it must check it to ensure its validity before processing and forwarding it on to its peers.\nProcess: When the node has checked that a TxPoW unit is valid, it will process it, adding to the chain if it meets the required difficulty level to become a block."),(0,o.kt)("p",null,"Diagram: The structure of a TxPoW Unit\nTxPoW ID\nHeader\nNonce (nonce)\nTimeMilli (timemilli)\nBlock Number (block)\nBlock Difficulty (blkdiff)\nCascade Levels (cascadelevels)\nParent Blocks  (superparents)\nMMR Root (mmr)\nMMR Total (total)\nMagic (magic)\nBody Hash (txbodyhash)"),(0,o.kt)("p",null,"Body\nRandom Number (prng)\nTxn Difficulty (txndiff)\nA Transaction (txn)\nA Witness (witness)\nBurn Txn (burntxn)\nBurn Witness (burnwitness)\nTxn List (txnlist)"),(0,o.kt)("p",null,"Header"),(0,o.kt)("p",null,"Header Field\nDescription\nNonce\nThe final nonce (number) that was included in the TxPoW header so that, when hashed, the required difficulty was achieved.\nTimeMilli\nTime this TxPoW was created in milliseconds since the epoch of 1970-01-01T00:00:00Z\nBlock Number\nBlock height to be used if this TxPoW unit becomes a block\nBlock Difficulty\nThe Difficulty required for this unit to be considered a valid block\nCascade Levels\nThe maximum number of levels in the Cascade (32)\nSuper Parents\nPointer to its immediate previous block and to the most recent block at each Super level. Used for cascading.\nMMR Root\nThe root hash of the MMR (to prove coins existed using a proof and header)\nMMR Total\nThe sum of all coins in the system (using a hash sum tree, the total amount of Minima is known every block removing the possibility of inflation bugs)\nMagic\nChain parameters - the magic numbers: desiredmaxtxpow, desiredmaxtxn, desiredmintxpowwork, maxtxpow,maxtxn,mintxpowwork\nTxBodyHash\nThe hash of the TxPoW body"),(0,o.kt)("p",null,"Body"),(0,o.kt)("p",null,"Body Field\nDescription\nRandom Number\nA Random number so that everyone is working on a different TxPoW in the pulse\nTxn Difficulty\nThe Difficulty required for this unit to be a valid TxPoW unit. The value that all users try to achieve when cycling through nonce values.\nA Transaction\nTransaction ID for the main transaction.\nUTxO (coin) inputs, outputs, state variables, linkhash and\nA Witness\nSignature Proofs, MMR Proofs (pointing to a valid unspent MMR entry in the past 24 hours for each input coin used in the txn), Script Proofs (for the various P2SH addresses used)\nBurn Txn\nInputs, outputs, state variables, linkhash and transaction ID for the Burn transaction paying for the transaction the user is trying to send. Can be empty.\nBurn Witness\nThe Witness data for the Burn. Signatures, MMR Proofs and scripts. Can be empty.\nTxn List\nList of the hashes of mempool transactions to propagate. These will become confirmed if this TxPoW unit becomes a block. Only the hash of transactions are added since transactions have already been sent across the network."),(0,o.kt)("p",null,"The Blockchain\nOverview\nThe Minima blockchain is structured to be compact and \u2018lightweight\u2019, it is therefore heavily pruned to meet this requirement. The chain itself is a tree of TxPoW blocks which hold transactions.\nAs the TxPow tree is pruned periodically, the headers from the \u2018heaviest\u2019 blocks (blocks with the highest difficulty by chance) are added into a \u2018Cascading\u2019 chain. The root of the TxPow tree always remains connected to the tip of the Cascading chain."),(0,o.kt)("p",null,"The TxPoW tree is the main blockchain, a chain of the most recent TxPoW units that met the difficulty required to become a block.\nThe Cascading chain is an unbroken chain of the headers of so called \u2018super blocks\u2019, designed to record and prove, in an immutable way, the total cumulative Proof-of-Work input into the network without having to keep a record of all individual blocks. Blocks are added to the Cascading chain on a periodic basis."),(0,o.kt)("p",null,"TxPoW Tree\nThe TxPoW tree is the main blockchain and has a root - the start of the chain, tip - end of the chain, blocks (nodes) and length (number of blocks).\nThe root of the chain meets the tip of the Cascade."),(0,o.kt)("p",null,"If a TxPoW unit becomes a block, it will have a static base weight equal to its difficulty and a total weight equal to its base weight plus the sum of the weights of its children. "),(0,o.kt)("p",null,"Base weight = Difficulty (i.e. number of hashes it took to mine the block)\nTotal weight = Base weight + Sum(Base weight of all children) "),(0,o.kt)("p",null,"By default, all blocks in the chain are Level 0 blocks."),(0,o.kt)("p",null,"Branching in the tree can occur if multiple blocks with the same height (block number) are found simultaneously. Branching is a natural occurrence and will resolve over time as a heavier branch continues to be built on."),(0,o.kt)("p",null,"All blocks in the tree are stored in a fast link hash table which provides a quick method of searching for blocks and determining how many blocks are in the tree, where for each block:\nKey (K) - TxPoW ID\nValue (V) - TxPoW object"),(0,o.kt)("p",null,"The Cascading Chain"),(0,o.kt)("p",null,"Cascading Chain"),(0,o.kt)("p",null,"Ghost algorithm\nThe GHOST (Greedy Heaviest Observed SubTree) protocol is used by Minima nodes to come to consensus on which chain is the valid one when multiple branches are established. Branching occurs naturally when two blocks with the same number (block height) are found simultaneously.\nRather than using the simple \u2018Longest chain\u2019 rule, where the valid chain is considered to be the one with the most number of blocks in it, GHOST considers the \u2018heaviest\u2019 chain to be the valid one. The \u2018heaviest\u2019 chain is the branch which has had the most Proof-of-Work put into it.\nThe faster the block time, the more likely it is that two blocks of the same number (height) will be found. If a simple \u2018Longest chain\u2019 rule applies, fast block times can reduce the security of the network if an attacker is able to secretly build a longer chain.\nGHOST was originally proposed as an alternative to Longest Chain by Sompolinsky and Zohar in the paper Secure High-Rate Transaction Processing in Bitcoin.\nDiagram illustrating the the main chain according to GHOST:"),(0,o.kt)("p",null,"Quantum Security\nIf Minima is truly expected to stand the test of time, it must be Quantum secure from the beginning. Once scaled to millions of nodes, each being complete - constructing and validating - nodes, the consensus critical components of the protocol must be finished, requiring no future changes.\nMinima\u2019s approach to Quantum security is two-fold:\nHashing\nMinima uses the Keccak hash algorithm with a hash strength of 256, considered to be post-quantum sufficient by the National Institute of Standards and Technology (NIST) see: ",(0,o.kt)("a",{parentName:"p",href:"https://csrc.nist.gov/csrc/media/projects/hash-functions/documents/keccak-slides-at-nist.pdf"},"https://csrc.nist.gov/csrc/media/projects/hash-functions/documents/keccak-slides-at-nist.pdf"),"\nKeccak is used for TxPoW mining, block and transaction hashes, proof chains, and signing or verifying data. All of the cryptographic security of Minima is provided by hash functions.\nSignatures\nMinima uses Winternitz One Time Signature (WOTS) with a Winternitz parameter of 8. WOTS is a hash based digital signature scheme which is considered quantum resistant.\n",(0,o.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2011/191.pdf"},"https://eprint.iacr.org/2011/191.pdf"),"\nThe cost of being Quantum secure is that signatures are at least 10-20x as big as Elliptic Curve Digital Signature Algorithm (ECDSA) used in Bitcoin. A one time use WOTS is 400-800 bytes. Minima signatures are certainly large when compared to normal Bitcoin transactions, but they are not kept forever since almost all data is eventually pruned, so although a bandwidth issue, they are only a temporary storage overhead"),(0,o.kt)("p",null,"Coloured coins\nMinima is the native coin for the Minima blockchain. Each UTxO is defined as a coin and therefore a coin can be worth any amount of Minima.\nMinima supports custom tokens (including NFTs) natively. Tokens are Coloured coins. Coloured coins are tiny fractions of Minima which represent the supply of a custom token or NFT.\nCustom tokens are specified by the following characteristics:\nTokenID\nCreated after all the details are set, by hashing the coinid and total amount. Each TokenID is globally unique\nToken Name/\nDescription\nA String description that can be just a name or a full JSON.\nCoinID\nThe CoinID used when creating the token initially\nTotal\nThe total number of these tokens\nDecimals\nThe number of decimal places to use for the token\nScript\nThe token script\nTotal Amount\nThe total amount of Minima coloured to be this token. Since Minima uses 44 decimal places, if you colour 1E-33 (0.000000000000000000000000000000001) Minima, that is 1000 tokens with 8 decimal places. i.e. 0.000000000000000000000000000000001000.00000000\nScale\nThe scale of the Token vs the amount. In the example above, the scale is 36"),(0,o.kt)("p",null,'NFTs are simply custom tokens with no decimal places i.e. they can only be spent whole.\nSmart Contracts\nMinima has its own,Turing Complete, scripting language for creating Smart Contracts.\nMinima, like Bitcoin, uses the UTxO model so writing smart contracts on Minima is quite different to writing them on an Account based model like Ethereum.\nA Minima script (contract) returns TRUE or FALSE. The default is return FALSE, so all scripts must explicitly RETURN TRUE for the transaction to be valid.\nA script can run for 512 instructions. An instruction is 1 operation or function.\nThe process to create a basic Smart Contract is as follows:\nWrite a script that will return TRUE when the funds should be spendable\nCreate the script, determining the address of the script. The address is the hash of the script.\nSend funds to the script address and set the state variables, this will lock the funds in a coin.\nAdd the coin as an input to a transaction. A transaction in Minima is a set of input coins, a set of output coins and a state variable list from 0-255. Each \u2018coin\u2019 has an amount, address (script hash), tokenid and coinid.\nThe transaction will only be valid when the script in the input coin returns TRUE, at which point the amount in the coin can be spent - in full.\nA \u2018contract\u2019 is the script that locks the funds in a coin and is interchangeable with the word script.\nA transaction can be signed by 1 or more public keys - and Signatures can even be added as state variables if you want oracle style contracts. Minima script is case sensitive.\nThe addition of the state variables in the MMR Proof DB, allow for complex scripts with knowledge of their past to be created. A simple state mechanic for transactional history rather than a global state for ALL transactions.\nEach user tracks the coins to an address they possess and all coins that have a public key or address they possess in the STATE or PREVSTATE.\nMinima transactions are scriptable Logic Gates, with analogue inputs and outputs, a simple yet powerful control language, and a previous history state mechanic.\nContracts are inherently compatible with Layer 2.\nThe scripting language supports SHA2-256 to allow cross-chain hash lock contracts with legacy chains.\nTypes of Contracts possible:\nBasic Signed\nTime Lock\nMulti-sig\nComplex multi-sig\nM of N multi-sig\nHashed Time Lock (including cross-chain)\nExchange\nFlashCash\nMAST\nExample multi-sig contract:\nscripts action:newscript track:true script:"RETURN SIGNEDBY(0x1539C2B974C1589C6AB3C734AA41D8E7D999759EFE057B047B200E836BA526 8A) AND SIGNEDBY(0xAD25E1E40605A68AFE357ECF83E51FE27EC10013851AE95889A00C695D5B94 02)" '),(0,o.kt)("p",null,"Token Scripts\nEach token has a separate script that must also return TRUE when attempting to spend a UTxO. For instance this could be 'make sure 1% is sent to this address, for a charity coin,\nRETURN VERIFYOUT(@INPUT CHARITY_ADDRESS @AMOUNT*0.01 @TOKENID) "),(0,o.kt)("p",null,"or a counter mechanism that checks a counter has been incremented:\nRETURN STATE(99) EQ INC(PREVSTATE(99))"),(0,o.kt)("p",null,"Both the address script and the Token script must return TRUE.\nA token by default has RETURN TRUE as it's script. This token structure is added to any transaction wishing to use that token so every user can know how many, what scripts, name etc of the Token is correct and valid."))}p.isMDXComponent=!0}}]);